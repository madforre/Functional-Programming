함수형 프로그래밍

    함수형 프로그래밍은 성공적인 프로그래밍을 위해 부수 효과를 미워하고
    조합성을 강조하는 프로그래밍 패러다임이다.

    * 부수효과를 미워한다. => 순수 함수를 만든다.
    * 조합성을 강조한다. => 모듈화 수준을 높인다.
    * 순수 함수 => 오류를 줄이고 안정성을 높인다.
    * 모듈화 수준이 높다.=> 생산성을 높인다. 
      (사용성, 성능, 확장성, 기회 변경에 대한 대응력이 좋다.)

    함수가 리턴 값으로 결과를 만드는 것 외에 외부 상태에 영향을 미치는 것을
    부수 효과라고 하는데, 순수함수는 부수 효과가 없는 함수이다.

    함수형 프로그래밍에서는 객체의 값을 조금 다른 방법으로 변형해 나간다.
    원래 있는 값은 그대로 두고 복사, 새로운 클론을 만들어서 원래의 값이
    변형된 새로운 값을 리턴하는 식이다.

함수형 프로그래밍 : 부수 효과를 없애고 순수 함수를 만들어 모듈화 수준을 높이는 프로그래밍 패러다임

  * 부수 효과 = 외부의 상태를 변경하는 것 또는 함수로 들어온 인자의 상태를 직접 변경하는 것

  * 순수 함수 = 부수효과가 없는 함수 즉, 어떤 함수에 동일한 인자를 주었을 때 항상 같은 값을 리턴하는 함수

                + 외부의 상태를 변경하지 않는 함수

  모듈화 수준이 높으면 재사용성이 높고 좋은 프로그래밍이라 할 수 있다.
  => 궁극적으로 평가 시점이 무관하다는 특성으로 효율적인 로직을 구성하는 것이 함수형 프로그래밍 패러다임이다.

  "순수 함수는 평가 시점이 중요하지 않다.(=언제, 어디서든 무관)"

  "순수 함수는 외부의 상태를 변경하지 않으면서 동일한 인자에 대해 항상 똑같은 값을 리턴하는 함수다."

  참고: https://jeong-pro.tistory.com/23


일급 함수 ( first-class function )

 - 값으로 담을 수 있는 함수이다.
 - 함수를 1급 객체로 다룰 수 있는 프로그래밍 언어의 성질, 그러한 함수
 - 변수에 할당, 전달 가능

일급 객체 ( First-class citizen )

 - 직관적으로 설명하자면, Function 이면서 Class의 성질인 지닌 객체 또는 Class이면서 
   Function의 성질을 지닌 객체를 First-Class Citizens 라고 이해할 수 있다.
   JavaScript 에서 Function에 Property를 줄 수 있는 것이 대표적인 예이다.

배경 지식

 first class citizen이란 자유롭게 거주하고 일 할 수 있고, 출입국의 자유를 가지며, 
 투표의 자유를 가지는 시민을 의미한다면, second class citizen이란 시민 또는 
 합법적 거주자이지만 시민권 및 사회 경제적 기회가 제한되어있는 시민을 의미합니다. 
 예를 들면, 19세기 초 참정권을 가진 남성이 first class citizen이라면, 
 참정권을 가지지 못했던 여성은 second class citizen이라고 할 수 있는 것이죠.

 프로그래밍 세계에서도 비슷한 개념이 존재합니다.
 프로그래밍 언어 디자인에서, 특정 언어의 first-class citizens은
 (first-class type, 또는 first-class object, 또는 first-class value 라고도 합니다.)
 보통 다른 객체들에게 적용 가능한 연산을 모두 지원하는 객체를 말합니다. 
 이러한 연산에는 보통 매개변수로 전달되고, 함수에서 반환되고 수정되고 변수에 할당되는 
 작업이 포함됩니다.

 즉! 프로그래밍 언어에서 type을 전달, 반환 및 할당 할 수 있는 경우 해당 type을 
 1급 객체로 간주됩니다. Javascript에서 함수를 반환할 수 있을 뿐만 아니라 
 함수를 받을 수 있는 함수를 만들수 있으니 함수형 프로그래밍으로 Javascript가 
 인기가 있어지는 이유이도 합니다. 그래서 하나 이상의 함수를 인수로 받거나 
 함수를 반환하는 고차 함수를 만들 수 있어요.

 참고 : https://medium.com/@soeunlee/javascript%EC%97%90%EC%84%9C-%EC%99%9C-%ED%95%A8%EC%88%98%EA%B0%80-1%EA%B8%89-%EA%B0%9D%EC%B2%B4%EC%9D%BC%EA%B9%8C%EC%9A%94-cc6bd2a9ecac

Higher-order-function(고차함수)

  Higher-order-function 이란 2가지 중 하나이상을 만족하는 함수를 말합니다.

  함수를 파라미터로 전달 받는 함수
  함수를 리턴하는 함수

일급 함수의 이러한 특징들을 이용하여
순수 함수들과 조합성을 높여나가는 것이 함수형 프로그래밍이다.

언제 평가해도 상관없는 순수함수들을 많이 만들고,
그 순수 함수들을 값으로 들고 다니면서 필요한 시점에
평가를 하는 방식이 함수형 프로그래밍이다.


MDN 클로저 정의

  “A closure is the combination of a function and the lexical environment within which that function was declared.”
  클로저는 함수와 그 함수가 선언됐을 때의 렉시컬 환경(Lexical environment)과의 조합이다.

  위 정의에서 말하는 “함수”란 반환된 내부함수를 의미하고 
  “그 함수가 선언될 때의 렉시컬 환경(Lexical environment)”란 내부 함수가
  선언됐을 때의 스코프를 의미한다. 즉, 클로저는 반환된 내부함수가 
  자신이 선언됐을 때의 환경(Lexical environment)인 스코프를 기억하여 
  자신이 선언됐을 때의 환경(스코프) 밖에서 호출되어도 
  그 환경(스코프)에 접근할 수 있는 함수를 말한다. 
  이를 조금 더 간단히 말하면 클로저는 자신이 생성될 때의 
  환경(Lexical environment)을 기억하는 함수다라고 말할 수 있겠다.

클로저가 사용되는 상황

  클로저가 가장 유용하게 사용되는 상황은 현재 상태를 기억하고 변경된 최신 상태를 유지하는 것.
  변수의 값은 누군가에 의해 언제든지 변경될 수 있어 오류 발생의 근본적 원인이 될 수 있다.
  상태 변경이나 가변(mutable) 데이터를 피하고 불변성(Immutability)을 지향하는 
  함수형 프로그래밍에서 부수 효과(Side effect)를 최대한 억제하여 오류를 피하고 
  프로그램의 안정성을 높이기 위해 클로저는 적극적으로 사용된다.

요즘 개발 이야기

  * 재미 / 실시간 : 라이브 방송, 실시간 댓글, 협업, 메신저 등등.. 요즘 트렌드임.
    ex) keynote

  * 독창성 / 완성도 : 애니메이션, 무한 스크롤, 벽돌 등등.. + ui / ux 

  * 동시성 : 

      비동기 I/O, 등등등.. 많은 사람들이 동시에 접속하는 것에 대한 대비가 필요하다.

  * 반응성 / 고가용성(죽지않는 서비스) : 

      서비스가 빨라야 한다, 죽지 않아야 한다. ELB, Auto Scaling 등등 
      사용자 급증에 대한 대비 필요

  * 대용량 / 정확성 / 병렬성 : 
  
      MapReduce, Clojure Reducers 등.. 많은 양의 데이터들을 빠르게 병렬 처리

  * 복잡도 / MSA :

      많아지고 세밀해지는 Tools - 도구들 
      독창성이 요구되다 보니
      작은 도구들을 모아서 하나의 소프트웨어를 만드는 형태로 발전했다.

  *** 그렇지만 타협할 수 없는 생산성 ***

  좋아지는 하드웨어 성능, 좋아지는 컴파일러 -> 함수형 프로그래밍이 스멀스멀 다가오는 중.

  동시성 + 병렬성, 분산이나 리액티브한 환경에 함수형 프로그래밍이 많이 채택되고 있다.


* 함수형 프로그래밍의 또 다른 정의.

  - 언어 자체를 함수처럼 여기도록 만들고, 이러한 함수 개념을 가장 우선순위에 놓는다.

* 함수형 사고방식

  - 문제의 해결 방법을 동사(함수)들로 구성(조합)하는 것이다.

    마이클 포거스, 클로저 플로그래밍의 즐거움에서... 클로저 진영의 핵심적인 기여를 한
    자바스크립트 핵심 개발자임.

    동사들을 통해서 구성해나가는 것! 함수형 프로그래밍!

* 그렇다면 함수를 우선으로 놓는다는 것은 무엇인가??

  단순하게 말하자면
  함수가 먼저 나오면 함수형 프로그래밍.
  객체가 먼저 나오면 객체지향 프로그래밍이다.

  객체지향 : 데이터를 먼저 디자인하고 데이터에 맞는 메서드를 만드는 식으로 프로그래밍한다.
  함수형 : 함수를 만들고 그 함수에 맞게 데이터 세트를 구성하는 식으로 프로그래밍한다.

---------------------------------------------------------------------------

필터와 같은 함수를 응용형 함수라고 한다. 함수를 인자로 받음.
함수가 함수를 받아서 원하는 시점에 해당 함수가 알고 있는 인자를
적용하는 것을 응용형 프로그래밍, 또는 적용형 프로그래밍이라고 한다.

* 원하는 시점에 평가한다는 것!!!
    
고차함수라고도 부른다. 함수를 인자로 받거나 함수를 리턴하거나
함수로 받은 인자를 함수내에서 실행하는 함수들을 고차함수라고 부른다.

함수형 프로그래밍은 추상화의 단위에 함수를 이용한다.
ex) 어떤 조건일 때 필터링 할지를 함수에게 위임한다.

필터함수는 리스트 인자랑 조건이 위임된 인자인 함수를 넘기고 새로운 리스트를 리턴하는 식으로 작동하고,
맵함수는 리스트 인자랑 맵핑할, 즉 수집할 데이터 키를 설정하는 조건 함수를 넘기고 맵핑되는 값들을 리턴하는 식으로
작동된다.

---------------------------------------------------------------------------

* 함수가 먼저 나오는 프로그래밍은 데이터가 있기 전부터 함수가 있고,
  데이터가 먼저 나오는 프로그래밍은 데이터가 있어야 메서드가 생긴다.

  객체지향은 평가의 순서가 굉장히 중요하게 된다!!! 해당하는 객체가 생겨야 기능을 수행할 수 있게됨!!

  함수 자체는 혼자 먼저 존재하기 때문에 데이터가 생기지 않아도 함수가 이미 존재하기 떄문에 평가 시점이 훨씬 유연해진다.
  여러가지 조합을 (조합성이 좋음) 만들 수 있다!!! 메서드 보다 다형성면에서, 실용성 면에서 좀더 좋은 점들이 있음!!

---------------------------------------------------------------------------

  함수형 프로그래밍에서는 함수가 어떤 역할을 하는지에 따라 이름을 갖는 것이 중요하다.
  단순히 역할을 수행한 다음에 돌려주는 콜백함수가 아닌, predi, iter, mapper 등 각각의 역할에 맞는 보조함수의 이름을
  따로 불러주는 것이 좋다.
  내부 다형성을 가지는 predi, iter, mapper 보조함수들.

  역할들을 책임지는 보조함수들!! 단순한 콜백이라고 보지말고 각각의 역할에 맞는 이름을 따로 불러주자!!
  조건이라던지 반복이라던지 역할을 책임지는 함수들임. 얘네들한테 위임하잖아.

  내부에서 데이터를 살펴보는게 아니라 역할을 위임하기 때문에 
  데이터형에 있어서 굉장히 자유롭고, 다형성을 높이는데 유리합니다.

  외부 다형성을 가지는 애들은 array_like, arguments, document.querySelectorAll

---------------------------------------------------------------------------

커링이란?

  함수와 인자를 다루는 기법이다.
  필요한 인자가 모두 채워지면 함수 본체를 실행하는 기법이다.

  자바스크립트에서는 커링이 지원되지 않지만, 일급함수가 지원되고 평가시점을 마음대로 다룰 수 있기 때문에
  커링과 같은 기법을 얼마든지 구현할 수 있다.

curryr

  curryr 을 통해 인자의 순서를 뒤집어서 평가할 수 있다.

유사배열 예제

  var a = document.querySelectorAll('*');

Array 에 slice를 적용 시킬 수 있는 방법??

  배열의 프로토타입에 있는 함수인 slice를 빌려쓴다!! (join, concat 메소드도 이 방식으로 사용 가능.)

  var slice = Array.prototype.slice;

  slice.call(a, 2);

  ArrayLike 객체가 와도 잘라줄 수 있다는 점!

_rest 함수

  리스트를 받고 자를 만큼의, 제외시킬 만큼의 넘버를 받는다.
  slice 보다 더 나아가서 arraylike 까지 잘라주는 함수이다.

ArrayLike

  뜻을 해석 하자면 배열 좋아가 아닌 배열과 유사한. 즉 배열 같은 오브젝트 입니다.
  반드시 length 프로퍼티가 정의되어 있어야 하며, key를 index number로 지정하여 사용할 수 있습니다.

파이프

  파이프는 함수들을 인자로 받아서 이 함수들을 연속으로 실행해주는 함수이다.
  연속 실행할 준비가 된 함수들을 리턴하는 함수이다.

  파이프는 결국엔 리듀스이다.
  파이프 보다 추상화된 함수가 리듀스임.

  * 함수들이라는 배열을 통해서 인자를 연속적으로 적용, 최종 결과로 축약하는 함수임.

call, apply, bind

  call은 보통 함수와 똑같이 인자를 넣고, apply는 인자를 하나로 묶어 배열로 만들어 넣음.

  실행 컨텍스트에서 this는 기본적으로 window이다.
  이 window를 다른 것으로 바꿀 수 있다.
  call, apply, bind에서 첫 번째 인자로 다른 것을 넣어주는 게 this를 바꾸는 방법이다.

  bind 함수?
  
    bind 함수는 함수가 가리키는 this만 바꾸고 호출하지는 않음.

    ex) 

      var obj = {
        string: 'zero',
        yell: function() {
          alert(this.string);
        }
      };
      var obj2 = {
        string: 'what?'
      };
      var yell2 = obj.yell.bind(obj2);
      yell2(); // 'what?'

      obj.yell.bind(obj2) 했더니 yell 함수의 this가 obj2로 바뀌었습니다. 
      즉 call이나 apply와 비슷하지만 호출은 하지 않지 않고 함수만 반환하는 겁니다. 
      call(this, 1, 2, 3)은 bind(this)(1, 2, 3)과 같죠.

_go

  go는 pipe의 즉시실행 버젼이라고 보면 된다.

pipe 나 go 함수는 코드를 보다 표현력 좋게 변화시킬 수 있다.

명령형으로 작성했던 코드들이 선언위주의 깔끔한 함수형으로 변화되는 과정이 느껴지나욤???

============================

컬렉션

  컬렉션은 돌림직한 데이터들을 다루는 것을 말함.

  컬렉션 중심 프로그래밍은 함수형 프로그래밍에서 빛을 발한다.
  실무에서 피할 수 없는 프로그래밍이다.

  컬렉션을 잘 다루는 함수 세트들을 잘 구성해 나가는 것을
  컬렉션 중심 프로그래밍이라고 합니다.
  주로 map, filter, reduce 등이 있어요.


컬렉션 중심 프로그래밍의 4가지 유형과 함수

  가장 맨 앞에 있는 애들은 대표 함수들임. (추상화 레벨이 높음)
  맨 앞에 있는 애들로 뒤에 있는 애들을 만들 수 있음.
  (map 으로 values, pluck / filter로 reject 등..)
  대표함수들을 통해 유형별로 특화 함수들을 만들 수 있다!
  map, filter, find, reduce 등의 
  고차 함수들을 중심으로 한프로그래밍입니다!

  1. 수집하기 - map, values, pluck 등
  2. 거르기 - filter, reject, compact, without 등
  3. 찾아내기 - find, some, every 등
  4. 접기 - reduce, min, max, group_by, count_by

  내가 만들고자 하는 어떤 문제를 어떤 함수로 해결해 나가는 지
  기준을 잡는 연습 또는 상상이 필요.

  함수들을 언제 쓰는지 명확히 알자!

  값을 찾아낼 때는 find, 집계를 할 때는 reduce,
  걸러낼 때는 filter 등등..

filter에서 쓰이는 두번째 인자 predi 뜻.

  프로그래밍 언어에서 사용하는 predicate는 
  서술어라기 보다는 논리에서 사용하는 
  긍정 또는 부정의 입언을 하는 개념으로 사용한다. true / false를 판단할 수 있는 식이나 boolean 값을 리턴하는 함수를 술어(predicate)라고 한다.

  predicate 뜻.

    - 술어[述語]
    - [논리]논리의 판단·명제에서, 주사(主辭)에 대하여 긍정 또는 부정의 입언(立言)을 하는 개념.
    - [언어] 같은 말 : 서술어.


filter에서 파생된 reject

  평가되었을 때,
  filter가 true로 된 값들을 꺼낸다면,
  reject는 true로 평가된 값들을 제외시킵니다.

  _negate라는 함수로 filter에서 reject를 만들었어요!


함수형 프로그래밍

  평가 시점들을 다루거나, 함수가 함수를 대신 실행한다던지,
  함수가 함수를 리턴하거나, 함수를 값으로 다룬다거나,
  인자로 받은 함수를 실행한 다음에 결과를 반대로 바꾼다음 리턴한다던지..
  이런식으로 함수의 응용과 조합을 강조하는 것이 함수형 프로그래밍이다.

  복잡한 기능을 가진 뚱뚱한 함수를 열 개 만드는 것보다
  서로다른 가벼운 함수를 만드는 것이 프로그래밍을 하면서
  더 유리하다.

  굉장히 다양하게 함수들을 조합하면서 
  약간만 변경된 함수들을 많이 만드는게 함수 진영의 목표임.

  _identity 라는 정말 아무것도 아닌 것 같은 함수가.. 
  실용적이고 간결, 조합성 증가에 이렇게나 좋다니!
  
  _negate라는 함수로 filter에서 reject를 만들었어요!
  굉장히 실용적이고 아름답군요!!

find 함수

  find 함수는 원하는 값을 찾고나면 빠져나온다.
  최적화의 포인트가 될 수 있음.
  나중에 지연 평가에 대한 이야기를 할 때에도 연관이 있다.
  굉장히 중요한 함수중 하나이다.

  조건에 만족하는, 첫번째 걸리는 놈의 값을 리턴함.

보조함수를 조합하면서 로직을 완성해나가는 것이 함수형 프로그래밍입니다!!!

  some, find, find_index나 다 고차함수로 사용되고 보조함수를 받기 때문에
  일반적인 find나 indexOf 보다 보조함수를 받아서 predi에 따라
  만족하는 값이 있느냐 없느냐 등.. 평가할 수 있다는 점!! 이것이 장점이자 차이점!!

  즉 내가 로직을 고르는 것과 같다.
  내가 원하는 대로 조건식을 만들어서 조합하고 평가할 수 있음.
  보조함수를 조합하면서 로직을 완성해나가는 것이 함수형 프로그래밍입니다!!!

_reduce를 사용할 때 주의점!

  접기를 만들 때, for문은 머릿속에서 지우도록 하자!
  reduce를 하면서, 한번씩 값을 돌면서 특정 함수를 실행한다면
  우리가 원하는 값이 나올 것이다. 라고 생각하도록 하자!!

  들어온 값에 대해서 어떤 값을 연속적으로 리턴하느냐?
  어떻게 계속 접어 나갈 것인가? 정제해나갈 것인가?
  이러한 생각을 바탕으로 결과를 만들어 나간다고 생각하고 사용하도록 하자.


아주 작은 로직도 함수 실행을 통해서 만들어 나가는 것이 함수형 프로그래밍입니다.

  _group_by에서 쓰인 _push 함수 처럼요.

함수형/이터러블 프로그래밍은 무엇을 대체 하는 것인지??

  이터러블 프로그래밍을 통해 명령형 코드를 대체합니다.
  i++, j++, if, for, break 등을 거의 사용하지 않게 되어 실수가 적어집니다.

  에러가 나기 쉬운 i++, j++, if, for, break 등의 명령형 코드를 더이상 작성하지 않을 수 있습니다. 
  에러율이 적으며, 생산성이 높고, 아름다운 표현력을 가진 함수형 코드를 작성할 수 있음!

짜잘한 팁

  document.write할 때는 document가 this로 있어야 동작을 하게끔 되어있음.

컬렉션 중심 프로그래밍을 마무리하며..

  어떤 로직을 만들 때 이 로직이 값을 수집하는 것인지,
  아니면 걸러내는 것인지, 어떤 특정 시점이나 특정 값을 찾아내는 것인지,
  아니면 접거나 집계를 하는 것인지, 먼저 유형을 분석한 다음에
  로직의 순서를 사고를 해나가면서 프로그래밍 할 수 있습니다.
  이렇게하면 문제를 보다 잘 정리된 패턴으로 분석을 할 수 있고,
  과제가 쉬워져 프로그래밍이 좀더 쉽게 이루어진다.

  for문이나 i++ J++ 등 이러한 코드들이 없고
  모든 함수들이 다양성이 높으면서도 안정성이 확보된 함수들을
  조립을 통해 프로그래밍 하기 때문에
  내가 만든 이 로직이 잘 돌아갈 것이다라는 확신이 좀 더 빨리
  들 수 있으며 테스트하기가 쉬워진다.
  ( 보조함수, 한 줄만 보고도 테스트를 할 수 있으므로. )

  이렇듯 이미 테스트가 잘 된 함수들의 조합을 통해서
  프로그래밍을 해나가다 보면은, 보다 빠르게 작성하는 프로그래밍이
  잘 동작하는 것에 대한 확신이 들 수 있다!!!

지연평가

  지연 평가를 시작 시키고 유지 시키는(이어 가는) 함수
    1. map
    2. filter, reject

  끝을 내는 함수
    1. take
    2. some, every, find

  순수함수는 순서와 상관없이 어느시점에서 어떻게 평가를 하던지간에
  동일한 결과를 나타내기 때문에 지연평가를 만들 수 있었다!!!

함수형 자바스크립트 요약!

  1. 함수를 되도록 작게 만들기

  2. 다형성 높은 함수 만들기

  3. 상태를 변경하지 않거나 정확히 다루어 부수 효과를 최소화 하기
    (부수 효과가 없을 수는 없다. 웹 브라우저 상태를 자바스크립트로 변경해야 되기 때문.)
    함수형 프로그래밍은 부수 효과로 가기 직전까지는 상태를 변경하지 않는 방식으로 프로그래밍을 하다가
    맨 마지막의 목적이 부수 효과가 되는 식으로 프로그래밍을 한다.

  4. 동일한 인자를 받으면 항상 동일한 결과를 리턴하는 순수 함수 만들기

  5. 복잡한 객체 하나를 인자로 사용하기보다 되도록 일반적인 값 여러 개를 인자로 사용하기

  6. 큰 로직을 고차 함수로 만들고 세부 로직을 보조 함수로 완성하기

  7. 어느곳에서든 바로 혹은 미뤄서 실행할 수 잇도록 일반 함수이자 순수 함수로 선언하기 (메서드가 아닌 순수 함수로 만들기)

  8. 모델이나 컬렉션 등의 커스텀 객체보다는 기본 객체를 이용하기

  9. 로직의 흐름을 최대한 단방향으로 흐르게 하기 (위에서부터 아래로. 단방향으로 흐르면서 함수를 조합해나가자.)

    즉, 데이터 흐름을 단방향으로 하는 것이 중요함!

    작은 함수들의 조합을 통해서 큰 함수를 만드는 식으로 프로그래밍 하는 것이
    함수형 자바스크립트라고 할 수 있다.

데이터 흐름 프로그래밍의 중요성

  클로저와 엘릭서 코드를 보면 중요성을 더더욱 빠르게 체감 할 수 있음!

  Clojure와 Elixir 읽기

    얘네들 역시 연속적으로 함수 중첩을 통해 데이터가 한 방향으로 흐르도록 프로그래밍 한다.

    함수형 프로그래밍으로 자바스크립트로 짠 코드와 거의 동일하다! 문법의 차이만 있을 뿐!!

    즉 함수형 프로그래밍은 어느 한 언어에 국한되어 있는 것이 아닌,
    하나의 패러다임이다!

  컬렉션 중심의 고차함수들을 익히고, 함수를 응용해나가면서
  순수함수들과 고차함수, 보조함수들로 프로그래밍하는 패러다임을 익히고 나면
  클로저나 엘릭서같이 다른 함수형 프로그래밍 언어를 익히는데에도 굉장히 쉬워집니다.

  지연평가를 지탱하는 기술은 어느 시점에서 평가하던 상관없는 순수함수이다.
  이 순수함수의 조합들로 이루어짐.

  어느 시점에서 평가하든지 상관이 없기 때문에,
  동시성, 병렬성 측면에서도 굉장히 유리해진다.

    ex) 클로저의 pmap (스레드가 나뉘어 병렬적으로 동작)
        클로저의 pcalls는 함수들을 담아두었다가 원하는 곳에서 평가할 수 있음.

        순수함수로 만든 add 함수는 fold, 접기가 가능하다.
        for문이 아닌, 접기. 즉 fold라고 생각하면 좋다.
        서로 다른 영역 혹은 스레드에서 병렬적으로 실행 후에 결과를 모아도
        동일한 결과를 내도록 만들 수 있다.

        예를 들면 클로저의 Reducers r/fold.
        서로 다른 영역에서 평가되면서 병렬적으로 처리가 되게 된다.
        자바스크립트 라이브러리 사용하여 지연평가시 (L. 붙이는거.)와 비슷하게
        클로저에서 reducers에 앞에 r/ 붙여주는 식으로 r/map, r/remove 이렇게 사용하면
        동일한 코드지만 내부적으로는 병렬적으로 동작하게 되므로
        2배정도의 성능을 더 내게 된다.

        병렬처리시 클로저에서 재밌는 점은 함수들이 즉시평가가 되지 않는다는 것이다.
        평가를 최대한 미룬 다음에 이러한 평가 일들을 준비할 객체를 집어넣어서
        서로 다른 스레드에서 출발시켜 프로그래밍의 성능을 튜닝해주는 아이디어인 점이다.

  데이터 프로그래밍의 중요성은 비동기 I/O나 Node.js 프로그래밍에서도 나옵니다.


Collection(컬렉션)

  자바에서는 '목록성 데이터를 처리하는 자료구조'를 통칭한다.
  프로그래밍에서 Collection 하면 목록성 데이터라고 생각하면 되겠다.

find

  _.find(list, predicate, [context]) Alias: detect 

  Looks through each value in the list, 
  returning the first one that passes a truth test (predicate), 
  or undefined if no value passes the test. 
  The function returns as soon as it finds an acceptable element, 
  and doesn't traverse the entire list. 
  predicate is transformed through iteratee to facilitate shorthand syntaxes.

  ex)
      var even = _.find([1, 2, 3, 4, 5, 6], function(num){ return num % 2 == 0; });
      => 2

contains

  _.contains(list, value, [fromIndex]) Aliases: include, includes 

  Returns true if the value is present in the list. Uses indexOf internally, if list is an Array. Use fromIndex to start your search at a given index.

  ex)
      _.contains([1, 2, 3], 3);
      => true

pluck

  _.pluck(list, propertyName) 

  A convenient version of what is perhaps the most common use-case for map: extracting a list of property values.

  ex)

      var stooges = [{name: 'moe', age: 40}, {name: 'larry', age: 50}, {name: 'curly', age: 60}];
      _.pluck(stooges, 'name');
      => ["moe", "larry", "curly"]

where

  _.where(list, properties) 

  Looks through each value in the list, 
  returning an array of all the values that matches the key-value pairs listed in properties.

  ex)
      _.where(listOfPlays, {author: "Shakespeare", year: 1611});
      => [{title: "Cymbeline", author: "Shakespeare", year: 1611},
          {title: "The Tempest", author: "Shakespeare", year: 1611}]

groupBy

  _.groupBy(collection, [iteratee=_.identity])

  ex)
      _.groupBy([6.1, 4.2, 6.3], Math.floor);
      // => { '4': [4.2], '6': [6.1, 6.3] }
      
      // The `_.property` iteratee shorthand.
      _.groupBy(['one', 'two', 'three'], 'length');
      // => { '3': ['one', 'two'], '5': ['three'] }

indexBy

  _.indexBy(list, iteratee, [context]) 

  Given a list, and an iteratee function that returns a key for each element in the list (or a property name), 
  returns an object with an index of each item. 
  Just like groupBy, but for when you know your keys are unique.

  ex)
      var stooges = [{name: 'moe', age: 40}, {name: 'larry', age: 50}, {name: 'curly', age: 60}];
      _.indexBy(stooges, 'age');
      => {
        "40": {name: 'moe', age: 40},
        "50": {name: 'larry', age: 50},
        "60": {name: 'curly', age: 60}
      }

extend 

  _.extend(destination, *sources)

  source 객체에 있는 모든 프로퍼티를 destination 객체에 복사하고, destination 객체를 리턴합니다. 
  source는 순서대로 처리하므로, 마지막 source의 프로퍼티가 앞의 인자들이 가진 
  같은 이름의 프로퍼티를 덮어쓸 수 있습니다.

  ex)
      var comments2 = _.map(comments, function(comment) {
          return _.extend({ // 객체를 확장하는 extend 함수. shallow copy도 해줌.
              user: _.find(users, function(user) {
                  return user.id == comment.user_id;
              })
          }, comment);
      });


Promise?

  Promise 는 javascript library 로 제공되기 시작했으며,
  현재는 ES6 부터는 언어 레벨에서 제공하는 기능입니다.

  프로미스는 자바스크립트 비동기 처리에 사용되는 객체입니다. 
  여기서 자바스크립트의 비동기 처리란,
  ‘특정 코드의 실행이 완료될 때까지 기다리지 않고 다음 코드를 먼저 수행하는 자바스크립트의 특성’ 을 의미합니다.
  프로미스는 주로 서버에서 받아온 데이터를 화면에 표시할 때 사용합니다.

  - Pending(대기)
  
    new Promise() 메서드를 호출하면 Pending(대기) 상태가 됩니다.
    아래처럼 new Promise() 메서드를 호출할 때 콜백 함수의 인자로 resolve, 
    reject에 접근할 수 있습니다.
    
    ex)
        new Promise(function (resolve, reject) {
          // ...
        });

  - Fulfilled(이행)

    콜백 함수의 인자 resolve를 아래와 같이 실행하면 Fulfilled(이행) 상태가 됩니다.
    
      new Promise(function (resolve, reject) {
        resolve();
      });

    그리고 이행 상태가 되면 아래와 같이 then()을 이용하여 처리 결과 값을 받을 수 있습니다.

      function getData() {
        return new Promise(function (resolve, reject) {
          var data = 100;
          resolve(data);
        });
      }

      // resolve()의 결과 값 data를 resolvedData로 받음
      getData().then(function (resolvedData) {
        console.log(resolvedData); // 100
      });

    프로미스의 '이행' 상태를 좀 다르게 표현해보면 '완료' 입니다.

    - Rejected(실패)

      new Promise()로 프로미스 객체를 생성하면 콜백 함수 인자로 
      resolve와 reject를 사용할 수 있다고 했습니다. 
      여기서 reject 인자로 reject() 메서드를 실행하면 Rejected(실패) 상태가 됩니다.

      new Promise(function (resolve, reject) {
        reject();
      });

      그리고, 실패 상태가 되면 실패한 이유(실패 처리의 결과 값)를 catch()로 받을 수 있습니다.

      function getData() {
        return new Promise(function (resolve, reject) {
          reject(new Error("Request is failed"));
        });
      }

      // reject()의 결과 값 Error를 err에 받음
      getData().then().catch(function (err) {
        console.log(err); // Error: Request is failed
      });

  - 여러 개의 프로미스 연결하기 (Promise Chaining)

    프로미스의 또 다른 특징은 여러 개의 프로미스를 연결하여 사용할 수 있다는 점입니다. 

    실제로 있을법한 예제
    ex)
        new Promise(function(resolve, reject){
          setTimeout(function() {
            resolve(1); // 여기서 1은 response.
          }, 2000);
        })
        .then(function(result) { // result는 응답받은 데이타인 response 1
          console.log(result); // 1
          return result + 10;
        })
        .then(function(result) {
          console.log(result); // 11
          return result + 20;
        })
        .then(function(result) {
          console.log(result); // 31
        });

      위 코드는 프로미스 객체를 하나 생성하고 setTimeout()을 이용해 
      2초 후에 resolve()를 호출하는 예제입니다.

      resolve()가 호출되면 프로미스가 대기 상태에서 이행 상태로 넘어가기 때문에 
      첫 번째 .then()의 로직으로 넘어갑니다. 
      
      첫 번째 .then()에서는 이행된 결과 값 1을 받아서 10을 더한 후 
      그다음 .then() 으로 넘겨줍니다. 
      
      두 번째 .then()에서도 마찬가지로 바로 이전 프로미스의 결과 값 11을 받아서 
      20을 더하고 다음 .then()으로 넘겨줍니다. 
      
      마지막 .then()에서 최종 결과 값 31을 출력합니다.

  - 에러 처리 방법

    2가지 방법이 있는데, 에러를 두번째 인자로 처리하는 방법과 catch()를 이용하는 방법이 있다.

    프로미스 에러 처리는 가급적 catch()를 사용하자. then()의 첫번째 콜백 함수 내부에서 오류가 나는 경우
    오류를 제대로 잡아내지 못하나, 똑같은 오류를 catch()로 처리하면 발생한 에러를 성공적으로 콘솔에 출력한다.
    더 많은 예외 처리 상황을 위해 프로미스의 끝에 가급적 catch()를 붙이도록 하자.

  코드가 동기적으로 동작하지 않고 순서와 상관없이 비동기적으로 동작할 때는
  코드의 순서를 개발자가 잘 제어해야하는 어려움이 있습니다.
  일반 콜백 함수만으로는 어려움이 있었는데, promise로 일정 부분 해결되었음.

프로미스의 3가지 상태(states)?

  프로미스의 상태(states)란? 
  여기서 말하는 상태란 프로미스의 처리 과정을 의미합니다. 
  new Promise()로 프로미스를 생성하고 종료될 때까지 3가지 상태를 갖습니다.

  * Pending(대기) : 비동기 처리 로직이 아직 완료되지 않은 상태
  * Fulfilled(이행) : 비동기 처리가 완료되어 프로미스가 결과 값을 반환해준 상태
  * Rejected(실패) : 비동기 처리가 실패하거나 오류가 발생한 상태

재귀 함수 관련

  재귀 함수란?

    재귀라는 단어를 국어사전에서는 "원래 자리로 되돌아 가거나 되돌아 옴" 이라고 하고 있습니다. 
    또한 익숙한 언어인 영어에서 재귀 대명사라는 말로 자기 자신을 가리키는 뜻으로 사용하기도 하죠. 
    이를 통하여 재귀함수는 자기 자신과 관련된 자기 자신에게 돌아오는 함수라고 유추해 볼 수 있겠습니다.
    한마디로 정리하자면 재귀함수는 자기 자신을 호출하는 함수입니다.

  재귀 함수의 성능을 검색해보면, 
  함수의 스택 call이 반복적으로 이루어지므로, 
  성능이 좋지 않다는 글을 종종 보게 된다.

  그렇다면 왜 쓰는가?

  재귀함수를 쓰는 이유

    - 1. 알고리즘 자체가 재귀적으로 표현하기 자연스러울 때. (가독성 이야기)
    - 2. 변수 사용을 줄여 준다.

  변수 사용을 줄여준다는건 변수가 잡는 메모리에 대한 이야기가 아니라,
  mutable state (변경 가능한 상태) 를 제거하여 프로그램 오류가 발생할 수 있는 가능성을 줄인다는 이야기다.
  함수형 프로그래밍에서, 함수를 일급 객체로 취급하여 함수를 인자로 전달 및 반환하여 mutable state 상태를 제거하는 것 처럼…

  재귀 함수는 장점만큼 단점도 크다.


일반적으로 재귀함수를 쓰지 않는 이유는? 
  
  메모리를 많이 차지하며 성능이 반복문에 비해 느리다.
  함수를 호출 시 함수의 매개변수, 지역변수, 리턴 값, 그리고 함수 종료 후 돌아가는 위치가 스택 메모리에 저장된다.
  재귀함수를 쓰게되면, 함수를 반복적으로 호출하므로, 스택 메모리가 커지고, 호출하는 횟수가 많아지면 스택오버플로우가 발생할 수 있다.
  또한 스택 프레임을 구성하고 해제하는 과정에서 반복문보다 오버헤드가 들어 성능도 느려진다.

꼬리재귀 ?

  꼬리 재귀는 재귀 함수를 호출할 때 스택을 재사용하면서 
  메모리를 과도하게 사용하지 않도록 최적화 하는 방법이다.

  꼬리 재귀는 기존 재귀의 위와 같은 문제점을 해결할 수 있는 방법이다. 
  꼬리 재귀의 장점을 얻으려면 2가지가 필요하다.
  
    1. 프로그래머가 재귀함수를 꼬리 재귀 방식으로 개발한다.
    2. 컴파일러가 꼬리 재귀 최적화를 지원해야 한다.
  
  컴파일러가 꼬리 재귀 최적화를 지원하지 않으면, 
  개발자가 꼬리 재귀 방식으로 개발해도 성능 및 메모리의 이점을 얻을 수 없다.

  ex) 

      int Recursive(int n) 
      {
      if(n==1) return 1;
      return n + Recursive(n-1);
      }
      int Tail_Recursive(int n, int acc)
      {
      if(n==1) return acc;
      return Tail_Recursive(n-1, n + acc );
      }

  일반 재귀는 함수의 마지막, return에 연산이 필요하다. (n + 함수(n-1))
  꼬리 재귀는 return에 연산이 필요없다. 
  매개변수로 필요한 연산을 전달한다. (함수(n-1, n+acc))
  여기서부터 꼬리 재귀의 이점은 컴파일러가 지원한다. 
  컴파일러가 꼬리 재귀를 최적화 할 수 있으면 최적화 하는 과정에서 
  꼬리 재귀를 반복문으로 변경한다.
  따라서 기존 재귀의 문제였던 메모리와 성능에 대한 문제가 제거되는 것이다.

재귀를 만들 때, 생각해야 할 두 가지 사항이 있다.

  탈출 조건, 즉 스스로 존재하는 원자적 정의를 만든다. (“기본 케이스” 라고 부른다)
  알고리즘의 어떤 부분이 재귀적인지를 정의한다.
  탈출 조건을 정의하고 나면, 함수가 언제 스스로를 다시 호출해야 하는지와 
  그 결과를 가지고 무엇을 해야 하는지를 결정하기가 쉽다.

  적절한 꼬리 호출이 코드 실행을 반드시 빠르게 해 주는 것은 아니라는 것. 
  사실은, 오히려 느리게 만드는 경우가 대부분이다.
  하지만, 꼬리 함수를 사용하게 되면 스택을 위한 메모리를 더 적게 
  사용할 수 있을 뿐만 아니라 국지적으로(locally) 할당된 객체들을 갖게됨으로써, 
  적은 메모리만 갖고도 재귀 함수를 실행할 수 있게 된다. 

  잠깐 삼천포로 빠졌었는데.. 암튼 알고만 있자.

  꼬리재귀 방식도 사용하는 언어 및 컴파일러 최적화 스펙등을 잘 살펴야 하는 것이고 
  이런방식은 대안이 있으면 굳이 사용할 필요가 없다.
  ES6에서 컴파일 잘 안되는 거 같고, 노드에서 따로 사용하려면 추가로 설치해야 할게 있는듯.

  어찌되었건 하노이의 탑, 순열 등 재귀적 사고도 해보면 좋다.

-----------------------------------------------------

마무리 하며

  필요한 로직을 항상 구현하는 것보다,
  이미 만들어진 함수형 함수나 고차함수를 통해서 프로그래밍하는 것이 
  훨씬 간결하고 쉽습니다.

  언제 평가해도 상관없는 함수들을 만들게 되면
  고차함수들과 조합을 할 수 있게 되고,
  고차함수가 비동기 상황을 대신해서 동기적으로 제어해준다던지 등등
  프로그래밍을 하기가 굉장히 쉬워집니다.

  Higher-order-function(고차함수)?

    Higher-order-function 이란 2가지 중 하나이상을 만족하는 함수를 말합니다.

    함수를 파라미터로 전달 받는 함수
    함수를 리턴하는 함수

  일급 함수의 이러한 특징들을 이용하여
  순수 함수들과 조합성을 높여나가는 것이 함수형 프로그래밍이다.

  언제 평가해도 상관없는 순수함수들을 많이 만들고,
  그 순수 함수들을 값으로 들고 다니면서 필요한 시점에
  평가를 하는 방식이 함수형 프로그래밍이다.

레벨업